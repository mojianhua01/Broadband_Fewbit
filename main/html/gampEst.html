
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>gampEst</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-06-02"><meta name="DC.source" content="gampEst.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">function</span> [out1,out2,out3,out4,out5,out6,out7,out8,out9] = <span class="keyword">...</span>
    gampEst(scaEstIn, scaEstOut, A, opt)
<span class="comment">% gampEst:  Generalized Approximate Message Passing -- Estimation algorithm</span>
<span class="comment">%</span>
<span class="comment">% DESCRIPTION:</span>
<span class="comment">% ------------</span>
<span class="comment">% The G-AMP estimation algorithm is intended for the estimation of a</span>
<span class="comment">% random vector x observed through an observation y from the Markov chain</span>
<span class="comment">%</span>
<span class="comment">%   x -&gt; z = A*x -&gt; y,</span>
<span class="comment">%</span>
<span class="comment">% where the prior p(x) and likelihood function p(y|z) are both separable.</span>
<span class="comment">%</span>
<span class="comment">% SYNTAX:</span>
<span class="comment">% -------</span>
<span class="comment">% [out1,out2,out3,out4,out5,out6,out7,out8,out9] = ...</span>
<span class="comment">%                               gampEst(scaEstIn, scaEstOut, A, opt)</span>
<span class="comment">%</span>
<span class="comment">% INPUTS:</span>
<span class="comment">% -------</span>
<span class="comment">% scaEstIn:  An input estimator derived from the EstimIn class</span>
<span class="comment">%    based on the input distribution p_X(x_j).</span>
<span class="comment">% scaEstOut:  An output estimator derived from the EstimOut class</span>
<span class="comment">%    based on the output distribution p_{Y|Z}(y_i|z_i).</span>
<span class="comment">% A:  Either a matrix or a linear operator defined by the LinTrans class.</span>
<span class="comment">% opt:  A set of options of the class GampOpt.</span>
<span class="comment">%</span>
<span class="comment">% OUTPUTS:</span>
<span class="comment">% --------</span>
<span class="comment">%  LEGACY FORMAT:</span>
<span class="comment">%  out1 = xhatFinal</span>
<span class="comment">%  out2 = xvarFinal [optional]</span>
<span class="comment">%  out3 = rhatFinal [optional]</span>
<span class="comment">%  out4 = rvarFinal [optional]</span>
<span class="comment">%  out5 = shatFinal [optional]</span>
<span class="comment">%  out6 = svarFinal [optional]</span>
<span class="comment">%  out7 = zhatFinal [optional]</span>
<span class="comment">%  out8 = zvarFinal [optional]</span>
<span class="comment">%  out9 = estHist [optional]</span>
<span class="comment">%</span>
<span class="comment">%  NEW FORMAT:</span>
<span class="comment">%  out1 = estFin</span>
<span class="comment">%  out2 = optFin</span>
<span class="comment">%  out3 = estHist [optional]</span>
<span class="comment">%</span>
<span class="comment">%   ... where ...</span>
<span class="comment">%</span>
<span class="comment">%  xhatFinal: final estimate of the vector x (output of x-estimator).</span>
<span class="comment">%  xvarFinal: final quadratic term for vector x (output of x-estimator).</span>
<span class="comment">%  phatFinal: final estimate of the vector p (input to z-estimator).</span>
<span class="comment">%  pvarFinal: final quadratic term for vector p (input to z-estimator).</span>
<span class="comment">%  zhatFinal: final estimate of the vector z=Ax (output of z-estimator).</span>
<span class="comment">%  zvarFinal: final quadratic term for vector z=Ax (output of z-estimator).</span>
<span class="comment">%  shatFinal: final estimate of the vector s (lagrange penalty on z-Ax).</span>
<span class="comment">%  svarFinal: final quadratic term for vector s (lagrange penalty on z-Ax).</span>
<span class="comment">%  rhatFinal: final estimate of the vector r (input to x-estimator).</span>
<span class="comment">%  rvarFinal: final quadratic term for vector r (input to x-estimator).</span>
<span class="comment">%</span>
<span class="comment">% estFin:  Final G-AMP estimation quantities</span>
<span class="comment">%   .xhat: same as xhatFinal above</span>
<span class="comment">%   .xvar: same as xvarFinal above</span>
<span class="comment">%   .Axhat: same as A*xhatFinal above</span>
<span class="comment">%   .phat: same as phatFinal above</span>
<span class="comment">%   .pvar: same as pvarFinal above</span>
<span class="comment">%   .zhat: same as zhatFinal above</span>
<span class="comment">%   .zvar: same as zvarFinal above</span>
<span class="comment">%   .shat: same as shatFinal above</span>
<span class="comment">%   .svar: same as svarFinal above</span>
<span class="comment">%   .rhat: same as rhatFinal above</span>
<span class="comment">%   .rvar: same as rvarFinal above</span>
<span class="comment">%   .xhatPrev: previous iteration of xhatFinal</span>
<span class="comment">%   .xhatNext: next iteration of xhat (used for warm start)</span>
<span class="comment">%   .xvarNext: next iteration of xvar (used for warm start)</span>
<span class="comment">%   .xhatDamp: damping state on xhat (used for warm start)</span>
<span class="comment">%   .pvarOpt = damping state on pvar (used for warm start)</span>
<span class="comment">%   .rvarOpt = damping state on rvar (used for warm start)</span>
<span class="comment">%   .A2xvarOpt = damping state on A2xvar (used for warm start)</span>
<span class="comment">%   .shatNext: next iteration of shat (used for warm start)</span>
<span class="comment">%   .svarNext: next iteration of svar (used for warm start)</span>
<span class="comment">%   .val: final value of utility (i.e., negative cost)</span>
<span class="comment">%   .valIn: final value of input utility (i.e., negative cost)</span>
<span class="comment">%   .valOpt: final record of input utilities (i.e., negative cost)</span>
<span class="comment">%   .scaleFac: final value of scaling used when varNorm=true</span>
<span class="comment">%   .step: final value of the stepsize (i.e., damping term)</span>
<span class="comment">%   .stepMax: final value of the maximum stepsize</span>
<span class="comment">%</span>
<span class="comment">% optFin:  Final settings of GampOpt options object (see GampOpt.m)</span>
<span class="comment">%</span>
<span class="comment">% estHist:  History of G-AMP across iterations</span>
<span class="comment">%   .xhat: history of xhat</span>
<span class="comment">%   .xvar: history of xvar</span>
<span class="comment">%   .Axhat: history of A*xhat</span>
<span class="comment">%   .phat: history of phat</span>
<span class="comment">%   .pvar: history of pvar</span>
<span class="comment">%   .zhat: history of zhat</span>
<span class="comment">%   .zvar: history of zvar</span>
<span class="comment">%   .shat: history of shat</span>
<span class="comment">%   .svar: history of svar</span>
<span class="comment">%   .rhat: history of rhat</span>
<span class="comment">%   .rvar: history of rvar</span>
<span class="comment">%   .pass: history of pass/fail</span>
<span class="comment">%   .val: history of the utility (i.e., negative cost)</span>
<span class="comment">%   .scaleFac: history of the scalefactor used when varNorm=true</span>
<span class="comment">%   .step: history of the stepsize (i.e., damping term)</span>
<span class="comment">%   .stepMax: history of the maximum allowed stepsize</span>
<span class="comment">%   .it = lists the iterations reported in the history</span>
<span class="comment">%</span>
<span class="comment">% Note that, in sum-product mode, the marginal posterior pdfs are</span>
<span class="comment">%    p(x(j)|y) ~= Cx*p(x(j))*exp( -(x(j)-rhat(j))^2/(2*rvar(j) )</span>
<span class="comment">%    p(z(i)|y) ~= Cz*p(y(i)|z(i))*exp( -(z(i)-phat(i))^2/(2*pvar(i) )</span>
<span class="comment">% where Cx and Cz are normalization constants.</span>


<span class="comment">% Get options</span>
<span class="keyword">if</span> (nargin &lt; 4) || isempty(opt)
    opt = GampOpt();
<span class="keyword">end</span>
nit     = opt.nit;              <span class="comment">% number of iterations</span>
step    = opt.step;             <span class="comment">% stepsize</span>
stepMin = opt.stepMin;          <span class="comment">% minimum stepsize</span>
stepMax = opt.stepMax;          <span class="comment">% maximum stepsize</span>
stepIncr = opt.stepIncr;        <span class="comment">% stepsize increase</span>
stepDecr = opt.stepDecr;        <span class="comment">% stepsize decrease</span>
adaptStep = opt.adaptStep;      <span class="comment">% utility-based adaptive stepsize on?</span>
adaptStepBethe = opt.adaptStepBethe; <span class="comment">%Use the cost computed from Bethe free energy</span>
stepWindow = opt.stepWindow;    <span class="comment">% adaptive stepsize: size of moving window</span>
bbStep = opt.bbStep;            <span class="comment">% Barzilai-Borwein-based stepsize adaptation on?</span>
verbose = opt.verbose;          <span class="comment">% Print results in each iteration?</span>
tol = opt.tol;                  <span class="comment">% Convergence tolerance</span>
maxBadSteps = opt.maxBadSteps;  <span class="comment">% maximum number of allowed failed iterations</span>
maxStepDecr = opt.maxStepDecr;  <span class="comment">% amount to decrease maxStep after failures</span>
stepTol = opt.stepTol;          <span class="comment">% minimum allowed stepsize</span>
pvarStep = opt.pvarStep;        <span class="comment">% include stepsize in pvar?</span>
rvarStep = opt.rvarStep;        <span class="comment">% include stepsize in rvar?</span>
varNorm = opt.varNorm;          <span class="comment">% normalize variances?</span>
scaleFac = opt.scaleFac;        <span class="comment">% initial variance normalization</span>
pvarMin = opt.pvarMin;          <span class="comment">% minimum value of pvar</span>
rvarMin = opt.xvarMin;          <span class="comment">% minimum value of rvar</span>
zvarToPvarMax = opt.zvarToPvarMax;  <span class="comment">% maximum zvar/pvar ratio</span>
histIntvl = opt.histIntvl;      <span class="comment">% history interval</span>

<span class="comment">% Handle output format</span>
legacyOut = opt.legacyOut;      <span class="comment">% use legacy output format?</span>
<span class="keyword">if</span> (legacyOut),
    saveHist = (nargout &gt;= 9);
    <span class="keyword">if</span> (nargout &gt; 9),
        error(<span class="string">'too many output arguments'</span>)
    <span class="keyword">end</span>;
<span class="keyword">else</span> <span class="comment">% modern output format</span>
    saveHist = (nargout &gt;= 3);
    <span class="keyword">if</span> (nargout &gt; 3),
        error(<span class="string">'too many output arguments'</span>)
    <span class="keyword">end</span>;
<span class="keyword">end</span>

<span class="comment">% Determine whether the utility must be computed each iteration</span>
<span class="keyword">if</span> adaptStep,
    compVal = true;             <span class="comment">% must be true</span>
<span class="keyword">else</span>
    compVal = false;            <span class="comment">% can set at false for faster runtime</span>
<span class="keyword">end</span>

<span class="comment">% Check for the presence of a custom stopping criterion in the options</span>
<span class="comment">% structure, and set flags as needed</span>
<span class="keyword">if</span> ~isempty(opt.stopFcn),
    customStop = 1;
    stopFcn = opt.stopFcn;
<span class="keyword">elseif</span> ~isempty(opt.stopFcn2),
    customStop = 2;
    stopFcn2 = opt.stopFcn2;
<span class="keyword">else</span>
    customStop = false;
<span class="keyword">end</span>

<span class="comment">% If A is an explicit matrix, replace by an operator</span>
<span class="keyword">if</span> isa(A, <span class="string">'double'</span>)
    A = MatrixLinTrans(A);
<span class="keyword">end</span>

<span class="comment">% Get dimensions</span>
[m,n] = A.size();
s = scaEstOut.numColumns();

<span class="comment">% Get default initialization values</span>
[xhat,xvar,valIn] = scaEstIn.estimInit();
valIn = sum( valIn(:) );

<span class="comment">% Replace default initialization with user-provided values</span>
<span class="keyword">if</span> ~isempty(opt.xhat0)
    <span class="keyword">if</span> sum(xhat~=opt.xhat0),
        valIn = -Inf; <span class="comment">% default valIn no longer valid</span>
    <span class="keyword">end</span>;
    xhat = opt.xhat0;
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(opt.xvar0)
    <span class="keyword">if</span> sum(xvar~=opt.xvar0),
        valIn = -Inf; <span class="comment">% default valIn no longer valid</span>
    <span class="keyword">end</span>;
    xvar = opt.xvar0;
<span class="keyword">end</span>
<span class="comment">%valIn = -Inf; % only for backwards compatibility.  Remove in next major revision?</span>
<span class="keyword">if</span> ~isempty(opt.valIn0)
    valIn = opt.valIn0;
<span class="keyword">end</span>
<span class="comment">%valOpt = [];     % empty initialization will cause the first iteration to be a "pass"</span>
valOpt = -Inf;
<span class="keyword">if</span> ~isempty(opt.valOpt0)
    valOpt = opt.valOpt0;
<span class="keyword">end</span>
val = nan;

<span class="comment">% For a scalar output, the same distribution is applied to all components</span>
<span class="keyword">if</span> (size(xhat,1) == 1)
    xhat = repmat(xhat,n,1);
<span class="keyword">end</span>
<span class="keyword">if</span> (size(xvar,1) == 1)
    xvar = repmat(xvar,n,1);
<span class="keyword">end</span>

<span class="comment">% Make sure that number of input columns match number of output columns</span>
<span class="keyword">if</span> (size(xhat,2) == 1)
    xhat = repmat(xhat,1,s);
<span class="keyword">end</span>
<span class="keyword">if</span> (size(xvar,2) == 1)
    xvar = repmat(xvar,1,s);
<span class="keyword">end</span>

<span class="comment">% Continue with initialization</span>
shat = zeros(m,s);      <span class="comment">% default value is zero</span>
svar = nan(m,s);        <span class="comment">% will test for NaN later</span>
xhatDamp = nan(n,s);    <span class="comment">% will test for NaN later</span>
pvarOpt = nan(m,s);     <span class="comment">% will test for NaN later</span>
rvarOpt = nan(n,s);     <span class="comment">% will test for NaN later</span>
A2xvarOpt = nan(m,s);   <span class="comment">% will test for NaN later</span>

<span class="comment">% Replace default initialization with user-provided values</span>
<span class="keyword">if</span> ~isempty(opt.shat0)
    shat = opt.shat0*scaleFac;  <span class="comment">% variance normalization included</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(opt.svar0)
    svar = opt.svar0*scaleFac;  <span class="comment">% variance normalization included</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(opt.xhatPrev0)
    xhatDamp = opt.xhatPrev0;
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(opt.pvarOpt0)
    pvarOpt = opt.pvarOpt0;
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(opt.rvarOpt0)
    rvarOpt = opt.rvarOpt0;
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(opt.A2xvarOpt0)
    A2xvarOpt = opt.A2xvarOpt0;
<span class="keyword">end</span>

<span class="comment">% Replace the stepMax adaptation quantities with user-provided values</span>
failCount = 0;
<span class="keyword">if</span> ~isempty(opt.failCount0)
    failCount = opt.failCount0;
<span class="keyword">end</span>

<span class="comment">% If the mean-removal option is set, create an augmented system</span>
<span class="comment">% with the mean removed.  (See LinTransDemeanRC.m for more details.)</span>
<span class="keyword">if</span> (opt.removeMean)
    A = LinTransDemeanRC(A,opt.removeMeanExplicit);
    [m,n] = A.size();
      maxSumVal = false; <span class="comment">% NEED A PROPER WAY TO SET THIS! Make maxSumVal a property of all estimOut?</span>
      isCmplx = false;  <span class="comment">% NEED A PROPER WAY TO SET THIS! Make isCmplx a property of all estimOut?</span>
    scaEstOut = A.expandOut(scaEstOut,maxSumVal,isCmplx);
    scaEstIn = A.expandIn(scaEstIn); <span class="comment">% SHOULD ALSO DEPEND ON maxSumVal and isCmplx!</span>
    xhat = A.expandXhat(xhat);
    xvar = A.expandXvar(xvar);
    shat = A.expandShat(shat);
    svar = A.expandSvar(svar);
    xhatDamp = A.expandXhat(xhatDamp);
    pvarOpt = A.expandSvar(pvarOpt);
    rvarOpt = A.expandXvar(rvarOpt);
    A2xvarOpt = A.expandSvar(A2xvarOpt);
<span class="keyword">end</span>

<span class="comment">% If uniform-variance mode is requested by the user, implement it by</span>
<span class="comment">% redefining the A.multSq and A.multSqTr operations</span>
<span class="keyword">if</span> (opt.uniformVariance)
    <span class="keyword">if</span> ~(opt.removeMean)
        A = UnifVarLinTrans(A);
    <span class="keyword">else</span>
        A = UnifVarLinTrans(A,1:m-2,1:n-2); <span class="comment">% don't average augmented elements</span>
    <span class="keyword">end</span>;
<span class="keyword">end</span>

<span class="comment">% If desired, automatically set xvar</span>
<span class="keyword">if</span> (opt.xvar0auto)
    xvarTol = 1e-4;
    zopt.maxIter = 100;
    zopt.stepsize = 0.25;
    zopt.regularization = 0;
    zopt.tol = 1e-4;
    zopt.debug = false;
    xopt = zopt; <span class="comment">% same options for x as for z</span>

    xhat0 = xhat;
    Axhat0 = A.mult(xhat0);
    <span class="keyword">for</span> t=1:100
        pvar = max(pvarMin, A.multSq(xvar));
        [phat,zhat,zvar,zstep] = estimInvert(scaEstOut,Axhat0,pvar,zopt);
        zopt.stepsize = zstep; <span class="comment">% update stepsize in case it changed</span>
        zopt.phat0 = phat; <span class="comment">% warm-start</span>
           <span class="comment">%NRz = norm(zhat(:)-Axhat0(:))/norm(Axhat0(:))</span>
        svar = (1-zvar./pvar)./pvar;
        rvar = max(rvarMin, 1./(A.multSqTr(svar)));
        xvarOld = xvar;
        [rhat,xhat,xvar,xstep] = estimInvert(scaEstIn,xhat0,rvar,xopt);
        xopt.stepsize = xstep; <span class="comment">% update stepsize in case it changed</span>
        xopt.phat0 = rhat; <span class="comment">% warm-start</span>
           <span class="comment">%NRx = norm(xhat(:)-xhat0(:))/norm(xhat0(:))</span>
        <span class="keyword">if</span> norm(xvar(:)-xvarOld(:))&lt;norm(xvar(:))*xvarTol, <span class="keyword">break</span>; <span class="keyword">end</span>;
    <span class="keyword">end</span>
    xhat = xhat0;
<span class="keyword">end</span>

<span class="comment">% Declare variables</span>
zhat = nan(m,s);
zvar = nan(m,s);
phat = nan(m,s);
rhat = nan(n,s);
rvar = nan(n,s);
xhatFinal = nan(n,s);
<span class="keyword">if</span> (saveHist)
    nitSave = floor(nit/histIntvl);
    estHist.xhat = nan(n*s,nitSave);
    estHist.xvar = nan(n*s,nitSave);
    estHist.Axhat = nan(m*s,nitSave);
    estHist.phat = nan(m*s,nitSave);
    estHist.pvar = nan(m*s,nitSave);
    estHist.shat = nan(m*s,nitSave);
    estHist.svar = nan(m*s,nitSave);
    estHist.zhat = nan(m*s,nitSave);
    estHist.zvar = nan(m*s,nitSave);
    estHist.rhat = nan(n*s,nitSave);
    estHist.rvar = nan(n*s,nitSave);
    estHist.step = nan(nitSave,1);
    estHist.val = nan(nitSave,1);
    estHist.stepMax = nan(nitSave,1);
    estHist.pass = nan(nitSave,1);
    estHist.scaleFac = nan(nitSave,1);
<span class="keyword">end</span>

<span class="comment">% Check for the presence of two methods within the LinTrans and EstimIn</span>
<span class="comment">% objects and set flags accordingly</span>
MtxUncertaintyFlag = ismethod(A,<span class="string">'includeMatrixUncertainty'</span>);
MsgUpdateFlag = ismethod(scaEstIn, <span class="string">'msgUpdate'</span>);

<span class="comment">% If using BB stepsize adaptation, compute column norms for use in scaling</span>
<span class="keyword">if</span> bbStep
    columnNorms = A.multSqTr(ones(m,1)).^0.5;
    columnNorms = repmat(columnNorms,1,s);
<span class="keyword">end</span>

<span class="comment">% Control variables to terminate the iterations</span>
stop = false;
it = 0;

<span class="comment">% Main iteration loop</span>
<span class="keyword">while</span> ~stop

    <span class="comment">% Iteration count</span>
    it = it + 1;

    <span class="comment">% Check for final iteration</span>
    <span class="keyword">if</span> it &gt;= nit
        stop = true;
    <span class="keyword">end</span>

    <span class="comment">% Check whether to save this iteration in history</span>
    <span class="keyword">if</span> saveHist &amp;&amp; rem(it,histIntvl)==0
        itSaveHist = it/histIntvl;
    <span class="keyword">else</span>
        itSaveHist = []; <span class="comment">% don't record</span>
    <span class="keyword">end</span>

    <span class="comment">% Output linear stage with no A uncertainty</span>
    A2xvar = A.multSq(xvar);

    <span class="comment">% Incorporate A uncertainty</span>
    <span class="keyword">if</span> MtxUncertaintyFlag
        pvar = A.includeMatrixUncertainty(A2xvar,xhat,xvar);
    <span class="keyword">else</span>
        pvar = A2xvar;
    <span class="keyword">end</span>

    <span class="comment">% Continued output linear stage</span>
    Axhat = A.mult(xhat);

    <span class="comment">% Step in pvar</span>
    <span class="keyword">if</span> pvarStep
        <span class="keyword">if</span> (it==1)
            <span class="keyword">if</span> any(isnan(pvarOpt)),    <span class="comment">% if user didn't specify opt.pvarOpt0</span>
                pvarOpt = pvar;        <span class="comment">% equivalent to making step=1</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> any(isnan(A2xvarOpt)),    <span class="comment">% if user didn't specify opt.A2xvarOpt0</span>
                A2xvarOpt = A2xvar;    <span class="comment">% equivalent to making step=1</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        pvar = (1-step)*pvarOpt + step*pvar;
        A2xvar = (1-step)*A2xvarOpt + step*A2xvar;
    <span class="keyword">end</span>

    <span class="comment">% Continued output linear stage</span>
    phat = Axhat - ((1/scaleFac)*A2xvar).*shat; <span class="comment">% Note: uses A2xvar rather than pvar</span>
    pvarRobust = max(pvar,pvarMin); <span class="comment">% At very high SNR, use very small pvarMin!</span>

    <span class="comment">% Compute expected log-likelihood of the output and add to negative</span>
    <span class="comment">% KL-divergence of the input, giving the current utility function</span>
    <span class="keyword">if</span> (compVal)
        <span class="keyword">if</span> ~adaptStepBethe
            valOut = sum(sum(scaEstOut.logLike(Axhat,pvar)));
        <span class="keyword">else</span>
            valOut = sum(sum(scaEstOut.logScale(Axhat,pvar,phat)));
        <span class="keyword">end</span>
        val = valOut + valIn;
    <span class="keyword">end</span>

    <span class="comment">% An iteration "passes" if any of below is true:</span>
    <span class="comment">% 1. Adaptive stepsizing is turned off</span>
    <span class="comment">% 2. Current stepsize is so small it can't be reduced</span>
    <span class="comment">% 3. The current utility at least as large as the worst in the stepWindow</span>
    <span class="comment">% Also, we force a pass on the first iteration else many quantities undefined</span>
    stopInd = length(valOpt);
    startInd = max(1,stopInd - stepWindow);
    valMin = min(valOpt(startInd:stopInd));
<span class="comment">%   pass = (~adaptStep) || (step &lt;= stepMin) || isempty(valMin) || (val &gt;= valMin);</span>
    pass = (it==1) || (~adaptStep) || (step &lt;= stepMin) || (val &gt;= valMin);

    <span class="comment">% Save the stepsize and pass/fail result if history requested</span>
    <span class="keyword">if</span> itSaveHist
        estHist.step(itSaveHist) = step;
        estHist.stepMax(itSaveHist) = stepMax;
        estHist.pass(itSaveHist) = pass;
    <span class="keyword">end</span>

    <span class="comment">% If pass, set the optimal values and compute a new target shat and snew.</span>
    <span class="keyword">if</span> (pass)

        <span class="comment">% Save states that "passed"</span>
        A2xvarOpt = A2xvar;
        pvarOpt = pvar;
        shatOpt = shat;
        svarOpt = svar;
        rvarOpt = rvar;
        xhatDampOpt = xhatDamp;
        xhatOpt = xhat;

        <span class="comment">% Save record of "passed" utilities</span>
        <span class="keyword">if</span> (compVal)
            valOpt = [valOpt val]; <span class="comment">%#ok&lt;AGROW&gt;</span>
        <span class="keyword">end</span>

        <span class="comment">% Store variables for export</span>
        phatFinal = phat;
        pvarFinal = pvar;
        zhatFinal = zhat;
        zvarFinal = zvar;
        xhatPrevFinal = xhatFinal; <span class="comment">% previous xhat</span>
        xhatFinal = xhat;
        xvarFinal = xvar;
        rhatFinal = rhat;
        rvarFinal = rvarOpt*scaleFac;   <span class="comment">% report unscaled version</span>
        AxhatFinal = Axhat;
        shatFinal = shatOpt/scaleFac;   <span class="comment">% report unscaled version</span>
        svarFinal = svarOpt/scaleFac;   <span class="comment">% report unscaled version</span>

        <span class="comment">% Check for convergence</span>
        <span class="keyword">if</span> (it&gt;1) &amp;&amp; (stop==false)
            <span class="keyword">if</span> (norm(xhatPrevFinal(:) - xhatFinal(:)) / norm(xhatFinal(:)) &lt; tol)
                stop = true;
            <span class="keyword">elseif</span> customStop==1
                stop = stopFcn(val, xhatFinal, xhatPrevFinal, AxhatFinal);
            <span class="keyword">elseif</span> customStop==2
                S = struct(<span class="keyword">...</span>
                    <span class="string">'it'</span>,it,<span class="keyword">...</span>
                    <span class="string">'val'</span>,val,<span class="string">'xhatPrev'</span>,xhatPrevFinal,<span class="string">'Axhat'</span>,AxhatFinal, <span class="keyword">...</span>
                    <span class="string">'xhat'</span>,xhatFinal,<span class="string">'xvar'</span>,xvarFinal,<span class="keyword">...</span>
                    <span class="string">'rhat'</span>,rhatFinal,<span class="string">'rvar'</span>,rvarFinal,<span class="keyword">...</span>
                    <span class="string">'phat'</span>,phatFinal,<span class="string">'pvar'</span>,pvarFinal,<span class="keyword">...</span>
                    <span class="string">'zhat'</span>,zhatFinal,<span class="string">'zvar'</span>,zvarFinal,<span class="keyword">...</span>
                    <span class="string">'shat'</span>,shatFinal,<span class="string">'svar'</span>,svarFinal <span class="keyword">...</span>
                    );
                stop = stopFcn2(S);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Set scaleFac to mean of pvar if variance-normalization is on.</span>
        <span class="comment">% Else scaleFac remains at the initialized value of 1 and has no effect</span>
        <span class="keyword">if</span> varNorm
            scaleFac = mean(pvarRobust(:));
        <span class="keyword">end</span>

        <span class="comment">% Output nonlinear stage</span>
        [zhat,zvar] = scaEstOut.estim(phat,pvarRobust);
        shatNew = (scaleFac./pvarRobust).*(zhat-phat);
        svarNew = (scaleFac./pvarRobust).*(1-min(zvar./pvarRobust,zvarToPvarMax));

        <span class="comment">% Compute new BB Step size if requested</span>
        <span class="keyword">if</span> bbStep &amp;&amp; it &gt; 2
            <span class="comment">% Compute previous step-direction/size weighted with column norms</span>
            sBB = (xhatOpt(1:n,:) - xhatDampOpt(1:n,:));

            <span class="comment">% Compute new stepsize using columnNorms weighting</span>
            <span class="comment">% Select the smallest stepsize over all the columns for a matrix</span>
            <span class="comment">% valued signal</span>
            values = sum(abs(sBB .* columnNorms).^2,1) ./<span class="keyword">...</span>
                sum(abs(A.mult(sBB).^2),1);
            step = min(values);
        <span class="keyword">end</span>

        <span class="comment">% Increase stepsize, keeping within bounds</span>
        step = min([stepIncr*max([step stepMin]) stepMax]);

    <span class="keyword">else</span> <span class="comment">% if not pass</span>

        <span class="comment">% Automatically decrease stepMax (when opt.maxBadSteps&lt;Inf)</span>
        failCount = failCount + 1;
        <span class="keyword">if</span> failCount &gt; maxBadSteps
            failCount = 0;
            stepMax = max(stepMin,maxStepDecr*stepMax);
        <span class="keyword">end</span>

        <span class="comment">% Decrease stepsize, keeping within bounds</span>
        step = min(max(stepMin, stepDecr*step),stepMax);

        <span class="comment">% Check for if stepsize is small enough to trigger termination</span>
        <span class="keyword">if</span> step &lt; stepTol
            stop = true;
        <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">% pass</span>

    <span class="comment">% Save results in history</span>
    <span class="keyword">if</span> (itSaveHist)
        estHist.phat(:,itSaveHist) = phatFinal(:);
        estHist.pvar(:,itSaveHist) = pvarFinal(:);
        estHist.zhat(:,itSaveHist) = zhatFinal(:);
        estHist.zvar(:,itSaveHist) = zvarFinal(:);
        estHist.shat(:,itSaveHist) = shatFinal(:);
        estHist.svar(:,itSaveHist) = svarFinal(:);
        estHist.rhat(:,itSaveHist) = rhatFinal(:);
        estHist.rvar(:,itSaveHist) = rvarFinal(:);
        estHist.xhat(:,itSaveHist) = xhatFinal(:);
        estHist.xvar(:,itSaveHist) = xvarFinal(:);
        estHist.Axhat(:,itSaveHist) = AxhatFinal(:);
        estHist.val(itSaveHist) = val; <span class="comment">% includes "failed" utilities</span>
        estHist.scaleFac(itSaveHist) = scaleFac;
    <span class="keyword">end</span>

    <span class="comment">% Print results</span>
    <span class="keyword">if</span> (verbose)
        fprintf(1,<span class="string">'it=%3d  val=%12.4e  stepsize=%f  |dx|/|x|=%12.4e\n'</span>, <span class="keyword">...</span>
            it, val, step, norm(xhatPrevFinal(:) - xhatFinal(:)) / norm(xhatFinal(:)));
    <span class="keyword">end</span>

    <span class="comment">% Apply damping to shat, svar, and xhat</span>
    <span class="keyword">if</span> (it==1)
        <span class="keyword">if</span> any(isnan(svarOpt)), <span class="comment">% if user didn't specify opt.svar0</span>
            svarOpt = svarNew;  <span class="comment">% equivalent to making step=1</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> any(isnan(xhatDampOpt)), <span class="comment">% if user didn't specify opt.xhatPrev0</span>
            xhatDampOpt = xhatOpt; <span class="comment">% equivalent to making step=1</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    shat = (1-step)*shatOpt + step*shatNew;
    svar = (1-step)*svarOpt + step*svarNew;
    xhatDamp = (1-step)*xhatDampOpt + step*xhatOpt;


    <span class="comment">% Step in rvar</span>
    rvar = 1./A.multSqTr(svar);   <span class="comment">% rvar = 1./((A.^2)*svar)</span>
    <span class="keyword">if</span> rvarStep
        <span class="keyword">if</span> (it==1)
            <span class="keyword">if</span> any(isnan(rvarOpt)),    <span class="comment">% if user didn't specify opt.rvarOpt0</span>
                rvarOpt = rvar;        <span class="comment">% equivalent to making step=1</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        rvar = (1-step)*rvarOpt + step*rvar;
    <span class="keyword">end</span>

    <span class="comment">% Input linear stage</span>
    rhat = xhatDamp + rvar.*(A.multTr(shat)); <span class="comment">% rhat = xhat + rvar.*(A'*shat)</span>
    rvarRobust = max(rvar, rvarMin);  <span class="comment">% At very high SNR, use very small rvarMin!</span>

    <span class="comment">% Input nonlinear stage</span>
    <span class="keyword">if</span> compVal
        <span class="comment">% Send messages to input estimation function.</span>
        <span class="keyword">if</span> MsgUpdateFlag
            valMsg = scaEstIn.msgUpdate(it, rhat, rvarRobust);
        <span class="keyword">else</span>
            valMsg = 0;
        <span class="keyword">end</span>

        <span class="comment">% Compute mean, variance, and negative KL-divergence</span>
        [xhat,xvar,valIn] = scaEstIn.estim(rhat, rvarRobust*scaleFac);
        valIn = sum( valIn(:) ) + valMsg;
    <span class="keyword">else</span>
        <span class="comment">% Compute mean and variance</span>
        [xhat,xvar] = scaEstIn.estim(rhat, rvarRobust*scaleFac);
    <span class="keyword">end</span>

<span class="keyword">end</span> <span class="comment">% main loop</span>

<span class="comment">% Store "next" (i.e., post-"final") estimates for export</span>
xhatNext = xhat;
xvarNext = xvar;
shatNext = shat/scaleFac;
svarNext = svar/scaleFac;


<span class="comment">% Trim the history if early termination occurred</span>
<span class="keyword">if</span> saveHist
    nitTrim = 1:floor(it/histIntvl);
    <span class="keyword">if</span> (it &lt; nit)
        estHist.xhat = estHist.xhat(:,nitTrim);
        estHist.xvar = estHist.xvar(:,nitTrim);
        estHist.Axhat = estHist.Axhat(:,nitTrim);
        estHist.phat = estHist.phat(:,nitTrim);
        estHist.pvar = estHist.pvar(:,nitTrim);
        estHist.zhat = estHist.zhat(:,nitTrim);
        estHist.zvar = estHist.zvar(:,nitTrim);
        estHist.shat = estHist.shat(:,nitTrim);
        estHist.svar = estHist.svar(:,nitTrim);
        estHist.rhat = estHist.rhat(:,nitTrim);
        estHist.rvar = estHist.rvar(:,nitTrim);
        estHist.pass = estHist.pass(nitTrim);
        estHist.val = estHist.val(nitTrim);
        estHist.scaleFac = estHist.scaleFac(nitTrim);
        estHist.step = estHist.step(nitTrim);
        estHist.stepMax = estHist.stepMax(nitTrim);
    <span class="keyword">end</span>
    estHist.it = (nitTrim(:))*histIntvl;
<span class="keyword">end</span>

<span class="comment">% Trim the outputs if mean removal was turned on</span>
<span class="keyword">if</span> (opt.removeMean)
    xhatNext = A.contract(xhatNext);
    xvarNext = A.contract(xvarNext);
    xhatDamp = A.contract(xhatDamp);
    xhatFinal = A.contract(xhatFinal);
    xvarFinal = A.contract(xvarFinal);
    xhatPrevFinal = A.contract(xhatPrevFinal);
    AxhatFinal = A.contract(AxhatFinal);
    phatFinal = A.contract(phatFinal);
    pvarFinal = A.contract(pvarFinal);
    pvarOpt = A.contract(pvarOpt);
    A2xvarOpt = A.contract(A2xvarOpt);
    zhatFinal = A.contract(zhatFinal);
    zvarFinal = A.contract(zvarFinal);
    shatFinal = A.contract(shatFinal);
    svarFinal = A.contract(svarFinal);
    shatNext = A.contract(shatNext);
    svarNext = A.contract(svarNext);
    rhatFinal = A.contract(rhatFinal);
    rvarFinal = A.contract(rvarFinal);
<span class="keyword">end</span>

<span class="comment">% Export outputs</span>
<span class="keyword">if</span> (legacyOut)
    out1 = xhatFinal;
    out2 = xvarFinal;
    out3 = rhatFinal;
    out4 = rvarFinal;
    out5 = shatFinal;
    out6 = svarFinal;
    out7 = zhatFinal;
    out8 = zvarFinal;
    <span class="keyword">if</span> (saveHist)
        out9 = estHist;
    <span class="keyword">end</span>
<span class="keyword">else</span>
    estFin.xhat = xhatFinal;
    estFin.xvar = xvarFinal;
    estFin.phat = phatFinal;
    estFin.pvar = pvarFinal;
    estFin.zhat = zhatFinal;
    estFin.zvar = zvarFinal;
    estFin.shat = shatFinal;
    estFin.svar = svarFinal;
    estFin.rhat = rhatFinal;
    estFin.rvar = rvarFinal;
    estFin.Axhat = AxhatFinal;
    estFin.xhatPrev = xhatPrevFinal; <span class="comment">% legacy warm-start</span>
    estFin.xhatNext = xhatNext; <span class="comment">% new warm-start</span>
    estFin.xvarNext = xvarNext; <span class="comment">% new warm-start</span>
    estFin.xhatDamp = xhatDamp; <span class="comment">% new warm-start</span>
    estFin.pvarOpt = pvarOpt; <span class="comment">% new warm-start</span>
    estFin.rvarOpt = rvarOpt; <span class="comment">% new warm-start</span>
    estFin.A2xvarOpt = A2xvarOpt; <span class="comment">% new warm-start</span>
    estFin.shatNext = shatNext; <span class="comment">% new warm-start</span>
    estFin.svarNext = svarNext; <span class="comment">% new warm-start</span>
    estFin.val = val;
    estFin.valIn = valIn;
    estFin.valOpt = valOpt;
    estFin.scaleFac = scaleFac;
    estFin.step = step;
    estFin.stepMax = stepMax;
    estFin.failCount = failCount;
    estFin.nit = it;
    out1 = estFin;
    out2 = opt;
    <span class="keyword">if</span> (saveHist)
        out3 = estHist;
    <span class="keyword">end</span>
<span class="keyword">end</span>;
</pre><pre class="codeoutput error">Error using gampEst (line 176)
Not enough input arguments.
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
function [out1,out2,out3,out4,out5,out6,out7,out8,out9] = ...
    gampEst(scaEstIn, scaEstOut, A, opt)
% gampEst:  Generalized Approximate Message Passing REPLACE_WITH_DASH_DASH Estimation algorithm
%
% DESCRIPTION:
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% The G-AMP estimation algorithm is intended for the estimation of a
% random vector x observed through an observation y from the Markov chain
%
%   x -> z = A*x -> y,
%
% where the prior p(x) and likelihood function p(y|z) are both separable.
%
% SYNTAX:
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
% [out1,out2,out3,out4,out5,out6,out7,out8,out9] = ...
%                               gampEst(scaEstIn, scaEstOut, A, opt)
%
% INPUTS:
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
% scaEstIn:  An input estimator derived from the EstimIn class
%    based on the input distribution p_X(x_j).
% scaEstOut:  An output estimator derived from the EstimOut class
%    based on the output distribution p_{Y|Z}(y_i|z_i).
% A:  Either a matrix or a linear operator defined by the LinTrans class.
% opt:  A set of options of the class GampOpt.
%
% OUTPUTS:
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%  LEGACY FORMAT:
%  out1 = xhatFinal
%  out2 = xvarFinal [optional]
%  out3 = rhatFinal [optional]
%  out4 = rvarFinal [optional]
%  out5 = shatFinal [optional]
%  out6 = svarFinal [optional]
%  out7 = zhatFinal [optional]
%  out8 = zvarFinal [optional]
%  out9 = estHist [optional]
%
%  NEW FORMAT:
%  out1 = estFin
%  out2 = optFin
%  out3 = estHist [optional]
%
%   ... where ...
%
%  xhatFinal: final estimate of the vector x (output of x-estimator).
%  xvarFinal: final quadratic term for vector x (output of x-estimator).
%  phatFinal: final estimate of the vector p (input to z-estimator).
%  pvarFinal: final quadratic term for vector p (input to z-estimator).
%  zhatFinal: final estimate of the vector z=Ax (output of z-estimator).
%  zvarFinal: final quadratic term for vector z=Ax (output of z-estimator).
%  shatFinal: final estimate of the vector s (lagrange penalty on z-Ax).
%  svarFinal: final quadratic term for vector s (lagrange penalty on z-Ax).
%  rhatFinal: final estimate of the vector r (input to x-estimator).
%  rvarFinal: final quadratic term for vector r (input to x-estimator).
%
% estFin:  Final G-AMP estimation quantities
%   .xhat: same as xhatFinal above
%   .xvar: same as xvarFinal above
%   .Axhat: same as A*xhatFinal above
%   .phat: same as phatFinal above
%   .pvar: same as pvarFinal above
%   .zhat: same as zhatFinal above
%   .zvar: same as zvarFinal above
%   .shat: same as shatFinal above
%   .svar: same as svarFinal above
%   .rhat: same as rhatFinal above
%   .rvar: same as rvarFinal above
%   .xhatPrev: previous iteration of xhatFinal
%   .xhatNext: next iteration of xhat (used for warm start)
%   .xvarNext: next iteration of xvar (used for warm start)
%   .xhatDamp: damping state on xhat (used for warm start)
%   .pvarOpt = damping state on pvar (used for warm start)
%   .rvarOpt = damping state on rvar (used for warm start)
%   .A2xvarOpt = damping state on A2xvar (used for warm start)
%   .shatNext: next iteration of shat (used for warm start)
%   .svarNext: next iteration of svar (used for warm start)
%   .val: final value of utility (i.e., negative cost)
%   .valIn: final value of input utility (i.e., negative cost)
%   .valOpt: final record of input utilities (i.e., negative cost)
%   .scaleFac: final value of scaling used when varNorm=true
%   .step: final value of the stepsize (i.e., damping term)
%   .stepMax: final value of the maximum stepsize
%
% optFin:  Final settings of GampOpt options object (see GampOpt.m)
%
% estHist:  History of G-AMP across iterations  
%   .xhat: history of xhat
%   .xvar: history of xvar
%   .Axhat: history of A*xhat
%   .phat: history of phat
%   .pvar: history of pvar
%   .zhat: history of zhat
%   .zvar: history of zvar
%   .shat: history of shat
%   .svar: history of svar
%   .rhat: history of rhat
%   .rvar: history of rvar
%   .pass: history of pass/fail
%   .val: history of the utility (i.e., negative cost)
%   .scaleFac: history of the scalefactor used when varNorm=true
%   .step: history of the stepsize (i.e., damping term)
%   .stepMax: history of the maximum allowed stepsize
%   .it = lists the iterations reported in the history
%
% Note that, in sum-product mode, the marginal posterior pdfs are
%    p(x(j)|y) ~= Cx*p(x(j))*exp( -(x(j)-rhat(j))^2/(2*rvar(j) )
%    p(z(i)|y) ~= Cz*p(y(i)|z(i))*exp( -(z(i)-phat(i))^2/(2*pvar(i) )
% where Cx and Cz are normalization constants.


% Get options
if (nargin < 4) || isempty(opt)
    opt = GampOpt();
end
nit     = opt.nit;              % number of iterations
step    = opt.step;             % stepsize
stepMin = opt.stepMin;          % minimum stepsize
stepMax = opt.stepMax;          % maximum stepsize
stepIncr = opt.stepIncr;        % stepsize increase
stepDecr = opt.stepDecr;        % stepsize decrease
adaptStep = opt.adaptStep;      % utility-based adaptive stepsize on?
adaptStepBethe = opt.adaptStepBethe; %Use the cost computed from Bethe free energy
stepWindow = opt.stepWindow;    % adaptive stepsize: size of moving window 
bbStep = opt.bbStep;            % Barzilai-Borwein-based stepsize adaptation on?
verbose = opt.verbose;          % Print results in each iteration?
tol = opt.tol;                  % Convergence tolerance
maxBadSteps = opt.maxBadSteps;  % maximum number of allowed failed iterations
maxStepDecr = opt.maxStepDecr;  % amount to decrease maxStep after failures
stepTol = opt.stepTol;          % minimum allowed stepsize
pvarStep = opt.pvarStep;        % include stepsize in pvar?
rvarStep = opt.rvarStep;        % include stepsize in rvar?
varNorm = opt.varNorm;          % normalize variances?
scaleFac = opt.scaleFac;        % initial variance normalization
pvarMin = opt.pvarMin;          % minimum value of pvar
rvarMin = opt.xvarMin;          % minimum value of rvar
zvarToPvarMax = opt.zvarToPvarMax;  % maximum zvar/pvar ratio
histIntvl = opt.histIntvl;      % history interval

% Handle output format
legacyOut = opt.legacyOut;      % use legacy output format?
if (legacyOut),
    saveHist = (nargout >= 9);
    if (nargout > 9),
        error('too many output arguments')
    end;
else % modern output format
    saveHist = (nargout >= 3);
    if (nargout > 3),
        error('too many output arguments')
    end;
end

% Determine whether the utility must be computed each iteration
if adaptStep,
    compVal = true;             % must be true
else
    compVal = false;            % can set at false for faster runtime
end

% Check for the presence of a custom stopping criterion in the options
% structure, and set flags as needed
if ~isempty(opt.stopFcn),
    customStop = 1;
    stopFcn = opt.stopFcn;
elseif ~isempty(opt.stopFcn2),
    customStop = 2;
    stopFcn2 = opt.stopFcn2;
else
    customStop = false;
end

% If A is an explicit matrix, replace by an operator
if isa(A, 'double')
    A = MatrixLinTrans(A);
end

% Get dimensions
[m,n] = A.size();
s = scaEstOut.numColumns();

% Get default initialization values
[xhat,xvar,valIn] = scaEstIn.estimInit();
valIn = sum( valIn(:) );

% Replace default initialization with user-provided values
if ~isempty(opt.xhat0)
    if sum(xhat~=opt.xhat0), 
        valIn = -Inf; % default valIn no longer valid
    end; 
    xhat = opt.xhat0;
end
if ~isempty(opt.xvar0)
    if sum(xvar~=opt.xvar0), 
        valIn = -Inf; % default valIn no longer valid
    end; 
    xvar = opt.xvar0;
end
%valIn = -Inf; % only for backwards compatibility.  Remove in next major revision?
if ~isempty(opt.valIn0)
    valIn = opt.valIn0; 
end
%valOpt = [];     % empty initialization will cause the first iteration to be a "pass"
valOpt = -Inf;     
if ~isempty(opt.valOpt0)
    valOpt = opt.valOpt0;       
end
val = nan;

% For a scalar output, the same distribution is applied to all components
if (size(xhat,1) == 1)
    xhat = repmat(xhat,n,1);
end
if (size(xvar,1) == 1)
    xvar = repmat(xvar,n,1);
end

% Make sure that number of input columns match number of output columns
if (size(xhat,2) == 1)
    xhat = repmat(xhat,1,s);
end
if (size(xvar,2) == 1)
    xvar = repmat(xvar,1,s);
end

% Continue with initialization
shat = zeros(m,s);      % default value is zero
svar = nan(m,s);        % will test for NaN later
xhatDamp = nan(n,s);    % will test for NaN later
pvarOpt = nan(m,s);     % will test for NaN later 
rvarOpt = nan(n,s);     % will test for NaN later 
A2xvarOpt = nan(m,s);   % will test for NaN later 

% Replace default initialization with user-provided values 
if ~isempty(opt.shat0)
    shat = opt.shat0*scaleFac;  % variance normalization included
end
if ~isempty(opt.svar0)
    svar = opt.svar0*scaleFac;  % variance normalization included
end
if ~isempty(opt.xhatPrev0)
    xhatDamp = opt.xhatPrev0;
end
if ~isempty(opt.pvarOpt0)
    pvarOpt = opt.pvarOpt0;
end
if ~isempty(opt.rvarOpt0)
    rvarOpt = opt.rvarOpt0;
end
if ~isempty(opt.A2xvarOpt0)
    A2xvarOpt = opt.A2xvarOpt0;
end

% Replace the stepMax adaptation quantities with user-provided values
failCount = 0;
if ~isempty(opt.failCount0)
    failCount = opt.failCount0;
end

% If the mean-removal option is set, create an augmented system
% with the mean removed.  (See LinTransDemeanRC.m for more details.)
if (opt.removeMean)
    A = LinTransDemeanRC(A,opt.removeMeanExplicit);
    [m,n] = A.size();
      maxSumVal = false; % NEED A PROPER WAY TO SET THIS! Make maxSumVal a property of all estimOut?
      isCmplx = false;  % NEED A PROPER WAY TO SET THIS! Make isCmplx a property of all estimOut?
    scaEstOut = A.expandOut(scaEstOut,maxSumVal,isCmplx);
    scaEstIn = A.expandIn(scaEstIn); % SHOULD ALSO DEPEND ON maxSumVal and isCmplx!
    xhat = A.expandXhat(xhat);
    xvar = A.expandXvar(xvar);
    shat = A.expandShat(shat);
    svar = A.expandSvar(svar);
    xhatDamp = A.expandXhat(xhatDamp);
    pvarOpt = A.expandSvar(pvarOpt);
    rvarOpt = A.expandXvar(rvarOpt);
    A2xvarOpt = A.expandSvar(A2xvarOpt);
end

% If uniform-variance mode is requested by the user, implement it by
% redefining the A.multSq and A.multSqTr operations
if (opt.uniformVariance)
    if ~(opt.removeMean)
        A = UnifVarLinTrans(A);
    else
        A = UnifVarLinTrans(A,1:m-2,1:n-2); % don't average augmented elements
    end;
end

% If desired, automatically set xvar
if (opt.xvar0auto)
    xvarTol = 1e-4;
    zopt.maxIter = 100;
    zopt.stepsize = 0.25;
    zopt.regularization = 0;
    zopt.tol = 1e-4;
    zopt.debug = false;
    xopt = zopt; % same options for x as for z
   
    xhat0 = xhat; 
    Axhat0 = A.mult(xhat0);
    for t=1:100
        pvar = max(pvarMin, A.multSq(xvar));
        [phat,zhat,zvar,zstep] = estimInvert(scaEstOut,Axhat0,pvar,zopt);
        zopt.stepsize = zstep; % update stepsize in case it changed
        zopt.phat0 = phat; % warm-start
           %NRz = norm(zhat(:)-Axhat0(:))/norm(Axhat0(:))
        svar = (1-zvar./pvar)./pvar;
        rvar = max(rvarMin, 1./(A.multSqTr(svar)));
        xvarOld = xvar;
        [rhat,xhat,xvar,xstep] = estimInvert(scaEstIn,xhat0,rvar,xopt);
        xopt.stepsize = xstep; % update stepsize in case it changed
        xopt.phat0 = rhat; % warm-start
           %NRx = norm(xhat(:)-xhat0(:))/norm(xhat0(:))
        if norm(xvar(:)-xvarOld(:))<norm(xvar(:))*xvarTol, break; end;
    end
    xhat = xhat0;
end

% Declare variables
zhat = nan(m,s);
zvar = nan(m,s);
phat = nan(m,s);
rhat = nan(n,s);                
rvar = nan(n,s);                
xhatFinal = nan(n,s);
if (saveHist)
    nitSave = floor(nit/histIntvl);
    estHist.xhat = nan(n*s,nitSave);
    estHist.xvar = nan(n*s,nitSave);
    estHist.Axhat = nan(m*s,nitSave);
    estHist.phat = nan(m*s,nitSave);
    estHist.pvar = nan(m*s,nitSave);
    estHist.shat = nan(m*s,nitSave);
    estHist.svar = nan(m*s,nitSave);
    estHist.zhat = nan(m*s,nitSave);
    estHist.zvar = nan(m*s,nitSave);
    estHist.rhat = nan(n*s,nitSave);
    estHist.rvar = nan(n*s,nitSave);
    estHist.step = nan(nitSave,1);
    estHist.val = nan(nitSave,1);
    estHist.stepMax = nan(nitSave,1);
    estHist.pass = nan(nitSave,1);
    estHist.scaleFac = nan(nitSave,1);
end

% Check for the presence of two methods within the LinTrans and EstimIn
% objects and set flags accordingly
MtxUncertaintyFlag = ismethod(A,'includeMatrixUncertainty');
MsgUpdateFlag = ismethod(scaEstIn, 'msgUpdate');

% If using BB stepsize adaptation, compute column norms for use in scaling
if bbStep
    columnNorms = A.multSqTr(ones(m,1)).^0.5;
    columnNorms = repmat(columnNorms,1,s);
end

% Control variables to terminate the iterations
stop = false;
it = 0;

% Main iteration loop
while ~stop
    
    % Iteration count
    it = it + 1;
    
    % Check for final iteration
    if it >= nit
        stop = true;
    end

    % Check whether to save this iteration in history
    if saveHist && rem(it,histIntvl)==0
        itSaveHist = it/histIntvl;
    else
        itSaveHist = []; % don't record
    end

    % Output linear stage with no A uncertainty
    A2xvar = A.multSq(xvar);
    
    % Incorporate A uncertainty
    if MtxUncertaintyFlag
        pvar = A.includeMatrixUncertainty(A2xvar,xhat,xvar);
    else
        pvar = A2xvar;
    end
    
    % Continued output linear stage
    Axhat = A.mult(xhat);
    
    % Step in pvar
    if pvarStep
        if (it==1)
            if any(isnan(pvarOpt)),    % if user didn't specify opt.pvarOpt0
                pvarOpt = pvar;        % equivalent to making step=1
            end
            if any(isnan(A2xvarOpt)),    % if user didn't specify opt.A2xvarOpt0
                A2xvarOpt = A2xvar;    % equivalent to making step=1
            end
        end
        pvar = (1-step)*pvarOpt + step*pvar;
        A2xvar = (1-step)*A2xvarOpt + step*A2xvar;
    end
    
    % Continued output linear stage
    phat = Axhat - ((1/scaleFac)*A2xvar).*shat; % Note: uses A2xvar rather than pvar
    pvarRobust = max(pvar,pvarMin); % At very high SNR, use very small pvarMin!
        
    % Compute expected log-likelihood of the output and add to negative 
    % KL-divergence of the input, giving the current utility function 
    if (compVal)
        if ~adaptStepBethe
            valOut = sum(sum(scaEstOut.logLike(Axhat,pvar)));
        else
            valOut = sum(sum(scaEstOut.logScale(Axhat,pvar,phat)));
        end
        val = valOut + valIn;
    end

    % An iteration "passes" if any of below is true: 
    % 1. Adaptive stepsizing is turned off
    % 2. Current stepsize is so small it can't be reduced 
    % 3. The current utility at least as large as the worst in the stepWindow  
    % Also, we force a pass on the first iteration else many quantities undefined
    stopInd = length(valOpt);
    startInd = max(1,stopInd - stepWindow);
    valMin = min(valOpt(startInd:stopInd));
%   pass = (~adaptStep) || (step <= stepMin) || isempty(valMin) || (val >= valMin);
    pass = (it==1) || (~adaptStep) || (step <= stepMin) || (val >= valMin);
    
    % Save the stepsize and pass/fail result if history requested
    if itSaveHist
        estHist.step(itSaveHist) = step;
        estHist.stepMax(itSaveHist) = stepMax;
        estHist.pass(itSaveHist) = pass;
    end
    
    % If pass, set the optimal values and compute a new target shat and snew.
    if (pass)
        
        % Save states that "passed" 
        A2xvarOpt = A2xvar;
        pvarOpt = pvar;
        shatOpt = shat;
        svarOpt = svar;
        rvarOpt = rvar;
        xhatDampOpt = xhatDamp; 
        xhatOpt = xhat;

        % Save record of "passed" utilities 
        if (compVal)
            valOpt = [valOpt val]; %#ok<AGROW> 
        end
        
        % Store variables for export
        phatFinal = phat;
        pvarFinal = pvar;
        zhatFinal = zhat;
        zvarFinal = zvar;
        xhatPrevFinal = xhatFinal; % previous xhat 
        xhatFinal = xhat;
        xvarFinal = xvar;
        rhatFinal = rhat;
        rvarFinal = rvarOpt*scaleFac;   % report unscaled version
        AxhatFinal = Axhat;
        shatFinal = shatOpt/scaleFac;   % report unscaled version
        svarFinal = svarOpt/scaleFac;   % report unscaled version
        
        % Check for convergence
        if (it>1) && (stop==false)
            if (norm(xhatPrevFinal(:) - xhatFinal(:)) / norm(xhatFinal(:)) < tol)
                stop = true;
            elseif customStop==1 
                stop = stopFcn(val, xhatFinal, xhatPrevFinal, AxhatFinal);
            elseif customStop==2 
                S = struct(...
                    'it',it,...
                    'val',val,'xhatPrev',xhatPrevFinal,'Axhat',AxhatFinal, ...
                    'xhat',xhatFinal,'xvar',xvarFinal,...
                    'rhat',rhatFinal,'rvar',rvarFinal,...
                    'phat',phatFinal,'pvar',pvarFinal,...
                    'zhat',zhatFinal,'zvar',zvarFinal,...
                    'shat',shatFinal,'svar',svarFinal ...
                    );
                stop = stopFcn2(S);
            end
        end
        
        % Set scaleFac to mean of pvar if variance-normalization is on.
        % Else scaleFac remains at the initialized value of 1 and has no effect
        if varNorm
            scaleFac = mean(pvarRobust(:));
        end
        
        % Output nonlinear stage
        [zhat,zvar] = scaEstOut.estim(phat,pvarRobust);
        shatNew = (scaleFac./pvarRobust).*(zhat-phat);
        svarNew = (scaleFac./pvarRobust).*(1-min(zvar./pvarRobust,zvarToPvarMax));
        
        % Compute new BB Step size if requested
        if bbStep && it > 2
            % Compute previous step-direction/size weighted with column norms
            sBB = (xhatOpt(1:n,:) - xhatDampOpt(1:n,:));
            
            % Compute new stepsize using columnNorms weighting
            % Select the smallest stepsize over all the columns for a matrix
            % valued signal
            values = sum(abs(sBB .* columnNorms).^2,1) ./...
                sum(abs(A.mult(sBB).^2),1);
            step = min(values);
        end
        
        % Increase stepsize, keeping within bounds
        step = min([stepIncr*max([step stepMin]) stepMax]);
        
    else % if not pass
        
        % Automatically decrease stepMax (when opt.maxBadSteps<Inf)
        failCount = failCount + 1;
        if failCount > maxBadSteps
            failCount = 0;
            stepMax = max(stepMin,maxStepDecr*stepMax);
        end
        
        % Decrease stepsize, keeping within bounds
        step = min(max(stepMin, stepDecr*step),stepMax);
        
        % Check for if stepsize is small enough to trigger termination
        if step < stepTol
            stop = true;
        end
    end % pass
    
    % Save results in history
    if (itSaveHist)
        estHist.phat(:,itSaveHist) = phatFinal(:);
        estHist.pvar(:,itSaveHist) = pvarFinal(:);
        estHist.zhat(:,itSaveHist) = zhatFinal(:);
        estHist.zvar(:,itSaveHist) = zvarFinal(:);
        estHist.shat(:,itSaveHist) = shatFinal(:);
        estHist.svar(:,itSaveHist) = svarFinal(:);
        estHist.rhat(:,itSaveHist) = rhatFinal(:);
        estHist.rvar(:,itSaveHist) = rvarFinal(:);
        estHist.xhat(:,itSaveHist) = xhatFinal(:);
        estHist.xvar(:,itSaveHist) = xvarFinal(:);
        estHist.Axhat(:,itSaveHist) = AxhatFinal(:);
        estHist.val(itSaveHist) = val; % includes "failed" utilities
        estHist.scaleFac(itSaveHist) = scaleFac;
    end
    
    % Print results
    if (verbose)
        fprintf(1,'it=%3d  val=%12.4e  stepsize=%f  |dx|/|x|=%12.4e\n', ...
            it, val, step, norm(xhatPrevFinal(:) - xhatFinal(:)) / norm(xhatFinal(:)));
    end
    
    % Apply damping to shat, svar, and xhat
    if (it==1)
        if any(isnan(svarOpt)), % if user didn't specify opt.svar0
            svarOpt = svarNew;  % equivalent to making step=1
        end
        if any(isnan(xhatDampOpt)), % if user didn't specify opt.xhatPrev0
            xhatDampOpt = xhatOpt; % equivalent to making step=1
        end
    end
    shat = (1-step)*shatOpt + step*shatNew;
    svar = (1-step)*svarOpt + step*svarNew;
    xhatDamp = (1-step)*xhatDampOpt + step*xhatOpt;
   
    
    % Step in rvar
    rvar = 1./A.multSqTr(svar);   % rvar = 1./((A.^2)*svar)  
    if rvarStep
        if (it==1)
            if any(isnan(rvarOpt)),    % if user didn't specify opt.rvarOpt0
                rvarOpt = rvar;        % equivalent to making step=1
            end
        end
        rvar = (1-step)*rvarOpt + step*rvar;
    end

    % Input linear stage
    rhat = xhatDamp + rvar.*(A.multTr(shat)); % rhat = xhat + rvar.*(A'*shat)
    rvarRobust = max(rvar, rvarMin);  % At very high SNR, use very small rvarMin!
    
    % Input nonlinear stage
    if compVal
        % Send messages to input estimation function.
        if MsgUpdateFlag
            valMsg = scaEstIn.msgUpdate(it, rhat, rvarRobust);
        else
            valMsg = 0;
        end

        % Compute mean, variance, and negative KL-divergence
        [xhat,xvar,valIn] = scaEstIn.estim(rhat, rvarRobust*scaleFac);
        valIn = sum( valIn(:) ) + valMsg;
    else
        % Compute mean and variance 
        [xhat,xvar] = scaEstIn.estim(rhat, rvarRobust*scaleFac);
    end
    
end % main loop

% Store "next" (i.e., post-"final") estimates for export
xhatNext = xhat;
xvarNext = xvar;
shatNext = shat/scaleFac;
svarNext = svar/scaleFac;


% Trim the history if early termination occurred
if saveHist
    nitTrim = 1:floor(it/histIntvl);
    if (it < nit)
        estHist.xhat = estHist.xhat(:,nitTrim);
        estHist.xvar = estHist.xvar(:,nitTrim);
        estHist.Axhat = estHist.Axhat(:,nitTrim);
        estHist.phat = estHist.phat(:,nitTrim);
        estHist.pvar = estHist.pvar(:,nitTrim);
        estHist.zhat = estHist.zhat(:,nitTrim);
        estHist.zvar = estHist.zvar(:,nitTrim);
        estHist.shat = estHist.shat(:,nitTrim);
        estHist.svar = estHist.svar(:,nitTrim);
        estHist.rhat = estHist.rhat(:,nitTrim);
        estHist.rvar = estHist.rvar(:,nitTrim);
        estHist.pass = estHist.pass(nitTrim);
        estHist.val = estHist.val(nitTrim);
        estHist.scaleFac = estHist.scaleFac(nitTrim);
        estHist.step = estHist.step(nitTrim);
        estHist.stepMax = estHist.stepMax(nitTrim);
    end
    estHist.it = (nitTrim(:))*histIntvl;
end

% Trim the outputs if mean removal was turned on
if (opt.removeMean)
    xhatNext = A.contract(xhatNext);
    xvarNext = A.contract(xvarNext);
    xhatDamp = A.contract(xhatDamp);
    xhatFinal = A.contract(xhatFinal);
    xvarFinal = A.contract(xvarFinal);
    xhatPrevFinal = A.contract(xhatPrevFinal);
    AxhatFinal = A.contract(AxhatFinal);
    phatFinal = A.contract(phatFinal);
    pvarFinal = A.contract(pvarFinal);
    pvarOpt = A.contract(pvarOpt);
    A2xvarOpt = A.contract(A2xvarOpt);
    zhatFinal = A.contract(zhatFinal);
    zvarFinal = A.contract(zvarFinal);
    shatFinal = A.contract(shatFinal);
    svarFinal = A.contract(svarFinal);
    shatNext = A.contract(shatNext);
    svarNext = A.contract(svarNext);
    rhatFinal = A.contract(rhatFinal);
    rvarFinal = A.contract(rvarFinal);
end

% Export outputs
if (legacyOut)
    out1 = xhatFinal;
    out2 = xvarFinal;
    out3 = rhatFinal;
    out4 = rvarFinal;
    out5 = shatFinal;
    out6 = svarFinal;
    out7 = zhatFinal;
    out8 = zvarFinal;
    if (saveHist)
        out9 = estHist;
    end
else
    estFin.xhat = xhatFinal;
    estFin.xvar = xvarFinal;
    estFin.phat = phatFinal;
    estFin.pvar = pvarFinal;
    estFin.zhat = zhatFinal;
    estFin.zvar = zvarFinal;
    estFin.shat = shatFinal;
    estFin.svar = svarFinal;
    estFin.rhat = rhatFinal;
    estFin.rvar = rvarFinal;
    estFin.Axhat = AxhatFinal; 
    estFin.xhatPrev = xhatPrevFinal; % legacy warm-start
    estFin.xhatNext = xhatNext; % new warm-start
    estFin.xvarNext = xvarNext; % new warm-start
    estFin.xhatDamp = xhatDamp; % new warm-start
    estFin.pvarOpt = pvarOpt; % new warm-start
    estFin.rvarOpt = rvarOpt; % new warm-start
    estFin.A2xvarOpt = A2xvarOpt; % new warm-start
    estFin.shatNext = shatNext; % new warm-start
    estFin.svarNext = svarNext; % new warm-start
    estFin.val = val;
    estFin.valIn = valIn;
    estFin.valOpt = valOpt;
    estFin.scaleFac = scaleFac;
    estFin.step = step;
    estFin.stepMax = stepMax;
    estFin.failCount = failCount;
    estFin.nit = it;
    out1 = estFin;
    out2 = opt;
    if (saveHist)
        out3 = estHist;
    end
end;

##### SOURCE END #####
--></body></html>